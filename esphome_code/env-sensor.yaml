# ESP Home Environmental Sensor Configuration
# Wemos D1 Mini + BME680 + 18650 Battery
# Deep sleep enabled for extended battery life

substitutions:
  device_name: "s1"
  friendly_name: "ENV-${device_name}"
  device_description: "Battery powered environmental sensor with BME680"
  
  # Deep sleep configuration 
  # IMPORTANT: Set to "false" for initial setup and programming
  # Set to "true" for battery-powered operation (requires D0-RST connection)
  deep_sleep_enabled: "true"  # Change to "true" to enable deep sleep mode
  # NOTE: Sleep duration now controlled via runtime "Sleep Interval" number input
  
  # Battery monitoring
  battery_update_interval: "60s"  # Battery check interval (normal mode)
  low_battery_threshold: "3.2"  # Voltage threshold for low battery alert (18650 cutoff)
  
  # NOTE: Sensor calibration now handled via runtime number inputs (removed static offsets)

# set platform and board
esp8266:
  board: esp01_1m

esphome:
  name: "${device_name}"
  friendly_name: ${friendly_name}
  comment: ${device_description}
  
  # Boot priority and initial setup
  on_boot:
    priority: -100
    then:
      - logger.log: "Device booted, starting sensor readings..."
      - delay: 2s  # Allow sensors to stabilize
      
      # Wait for Home Assistant API connection to sync entity states
      - logger.log: "Waiting for Home Assistant connection to sync calibration values..."
      - delay: 10s  # Allow HA to connect and sync number input states
      
      # Log the current calibration values and switch states after HA sync
      - logger.log: 
          format: "Calibration values - Temp: %.1f°F, Pressure: %.1f hPa, Humidity: %.1f%%, Voltage: %.2fx"
          args: 
            - 'id(temperature_offset_input).state'
            - 'id(pressure_offset_input).state' 
            - 'id(humidity_offset_input).state'
            - 'id(voltage_multiplier_input).state'
      - logger.log:
          format: "Gas Resistance Offset: %.0fΩ"
          args: 
            - 'id(gas_resistance_offset_input).state'
      - logger.log:
          format: "Deep Sleep Settings - Switch: %s, Interval: %.1f minutes"
          args: 
            - 'id(deep_sleep_toggle).state ? "ENABLED" : "DISABLED"'
            - 'id(sleep_interval_input).state'
      
      # Update deep sleep duration based on saved interval value
      - lambda: |-
          float minutes = id(sleep_interval_input).state;
          uint32_t milliseconds = (uint32_t)(minutes * 60.0 * 1000.0);
          ESP_LOGI("deep_sleep", "Setting initial sleep duration to %.1f minutes (%u ms)", minutes, milliseconds);
          id(deep_sleep_control).set_sleep_duration(milliseconds);
      
      # Always take sensor readings first
      - component.update: bme680_sensor
      - component.update: battery_voltage
      - delay: 5s  # Allow readings to complete and transmit
      
      # Now check deep sleep settings
      - if:
          condition:
            # Check both compile-time setting AND runtime switch state
            lambda: |-
              bool compile_time_enabled = (strcmp("${deep_sleep_enabled}", "true") == 0);
              bool runtime_switch_enabled = id(deep_sleep_toggle).state;
              ESP_LOGI("main", "Compile-time deep sleep: %s", compile_time_enabled ? "enabled" : "disabled");
              ESP_LOGI("main", "Runtime switch state: %s", runtime_switch_enabled ? "enabled" : "disabled");
              return compile_time_enabled && runtime_switch_enabled;
          then:
            - logger.log: "Deep sleep mode active - entering sleep after readings"
            - delay: 5s  # Final delay before sleep
            - logger.log: "Entering deep sleep"
            - deep_sleep.enter: deep_sleep_control
          else:
            - if:
                condition:
                  lambda: 'return strcmp("${deep_sleep_enabled}", "true") == 0;'
                then:
                  - logger.log: "SUCCESS: Deep sleep compiled but disabled by HA switch - staying awake for normal operation"
                else:
                  - logger.log: "Deep sleep not compiled - normal mode with 30s intervals"

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${device_name} Fallback"
    password: !secret ap_password

# Captive portal for easy WiFi configuration
captive_portal:

# Enable logging
logger:
  level: INFO  # Show INFO level logs including logger.log messages
  baud_rate: 115200  # Enable serial logging for debugging

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key
  
  # Services for remote control
  services:
    - service: start_deep_sleep
      then:
        - logger.log: "Starting deep sleep via service call"
        - homeassistant.service:
            service: notify.notify
            data:
              title: "${friendly_name}"
              message: "Manually entering deep sleep mode"
        - deep_sleep.enter: deep_sleep_control
    


# Enable OTA updates
ota:
  platform: esphome
  password: !secret ota_password

# Web server for diagnostics (optional - disable to save power)  
# ENABLED: For viewing logs and diagnostics
web_server:
  port: 80
  # auth:
  #   username: !secret web_username
  #   password: !secret web_password

# Deep sleep configuration (only active when deep_sleep_enabled is "true")
# IMPORTANT: For deep sleep to work, you MUST connect GPIO16 (D0) to RST pin
# This allows the ESP8266 to wake itself up from deep sleep
deep_sleep:
  id: deep_sleep_control
  sleep_duration: 1min  # Default duration, will be updated dynamically
  # Note: ESP8266 doesn't support wakeup_pin - uses GPIO16 to RST connection instead

# I2C configuration for BME680
i2c:
  sda: GPIO4  # D2 on Wemos D1 Mini
  scl: GPIO5  # D1 on Wemos D1 Mini
  scan: true
  frequency: 100kHz

# BME680 sensor configuration
sensor:
  # BME680 Environmental Sensor
  - platform: bme680
    id: bme680_sensor
    temperature:
      name: "Temperature"
      id: temperature
      accuracy_decimals: 1
      filters:
        # Runtime calibration via lambda using number input (Fahrenheit to Celsius conversion)
        - lambda: |-
            float offset_f = id(temperature_offset_input).state;
            float offset_c = offset_f / 1.8;  // Convert Fahrenheit offset to Celsius
            return x + offset_c;
    pressure:
      name: "Pressure"
      id: pressure
      accuracy_decimals: 1
      filters:
        # Runtime calibration via lambda using number input
        - lambda: 'return x + id(pressure_offset_input).state;'
    humidity:
      name: "Humidity"
      id: humidity
      accuracy_decimals: 1
      filters:
        # Runtime calibration via lambda using number input
        - lambda: 'return x + id(humidity_offset_input).state;'
    gas_resistance:
      name: "Gas Resistance"
      id: gas_resistance
      accuracy_decimals: 0
      filters:
        # Runtime calibration via lambda using number input (convert kΩ to Ω)
        - lambda: |-
            float offset_kohms = id(gas_resistance_offset_input).state;
            float offset_ohms = offset_kohms * 1000.0;  // Convert kΩ to Ω
            return x + offset_ohms;
    address: 0x77  # Default I2C address (0x76 is also common)
    update_interval: never  # Will be manually triggered in both modes
    
    # BME680 specific configuration
    iir_filter: 3x  # Internal IIR filter
    heater:
      temperature: 320  # Heater temperature in Celsius
      duration: 150ms
  
  # Battery voltage monitoring
  - platform: adc
    pin: A0
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: ${battery_update_interval}
    accuracy_decimals: 2
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    filters:
      # Convert ADC reading to voltage using runtime adjustable multiplier
      - lambda: |-
          float multiplier = id(voltage_multiplier_input).state;
          return x * multiplier;
    on_value:
      then:
        - if:
            condition:
              lambda: 'return x < ${low_battery_threshold};'  # Low battery threshold
            then:
              - logger.log: 
                  format: "Low battery detected: %.2fV"
                  args: ['x']
              - homeassistant.service:
                  service: notify.notify
                  data:
                    title: "${friendly_name}"
                    message: "Low battery detected - check device"
                    priority: high
  
  # Battery level percentage (calculated from voltage)
  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      float voltage = id(battery_voltage).state;
      
      // Li-ion battery discharge curve (3.2V - 4.2V range)
      if (voltage >= 4.1) return 100;
      if (voltage >= 4.0) return 95;
      if (voltage >= 3.9) return 85;
      if (voltage >= 3.8) return 75;
      if (voltage >= 3.7) return 65;
      if (voltage >= 3.6) return 45;
      if (voltage >= 3.5) return 30;
      if (voltage >= 3.4) return 15;
      if (voltage >= 3.3) return 5;
      if (voltage >= 3.2) return 1;
      return 0;  // Battery critically low
    update_interval: ${battery_update_interval}
  
  # WiFi signal strength
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    id: wifi_signal_db
    update_interval: ${battery_update_interval}
    accuracy_decimals: 0
    device_class: signal_strength
    state_class: measurement
    entity_category: diagnostic
  
  # Uptime sensor
  - platform: uptime
    name: "${friendly_name} Uptime"
    id: uptime_sensor
    update_interval: ${battery_update_interval}
    entity_category: diagnostic
  
  # Current sleep interval display - DISABLED to save memory
  # - platform: template
  #   name: "${friendly_name} Sleep Interval Setting"
  #   id: sleep_interval_display
  #   unit_of_measurement: "min"
  #   accuracy_decimals: 0
  #   state_class: measurement
  #   entity_category: diagnostic
  #   icon: "mdi:sleep"
  #   lambda: |-
  #     return 15.0; // Matches sleep_duration substitution default
  #   update_interval: 60s
  
  # NOTE: Calibrated sensors removed - use runtime offset number inputs instead
  # Temperature/Pressure/Humidity offsets are applied directly via filters in BME680 sensor
  
  # Air Quality Index (calculated from gas resistance)
  - platform: template
    name: "Air Quality Index"
    id: air_quality_index
    unit_of_measurement: "AQI"
    device_class: aqi
    state_class: measurement
    accuracy_decimals: 0
    icon: "mdi:air-filter"
    entity_category: diagnostic
    lambda: |-
      float gas_val = id(gas_resistance).state;
      
      // BME680 gas resistance to AQI conversion
      // Higher gas resistance = better air quality
      // Typical ranges: 10kΩ (poor) to 200kΩ+ (excellent)
      
      if (gas_val >= 150000) {
        return 50;   // Excellent (0-50 AQI)
      } else if (gas_val >= 100000) {
        return 75;   // Good (51-100 AQI)
      } else if (gas_val >= 50000) {
        return 125;  // Moderate (101-150 AQI)
      } else if (gas_val >= 25000) {
        return 175;  // Unhealthy for sensitive (151-200 AQI)
      } else if (gas_val >= 10000) {
        return 225;  // Unhealthy (201-250 AQI)
      } else {
        return 300;  // Very Unhealthy/Hazardous (251+ AQI)
      }
  
  # Air Quality Percentage (0-100% scale)
  - platform: template
    name: "Air Quality Percentage"
    id: air_quality_percentage
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 0
    icon: "mdi:leaf"
    lambda: |-
      float gas_val = id(gas_resistance).state;
      
      // Convert gas resistance to 0-100% scale
      // 10kΩ = 0%, 200kΩ = 100%
      float min_resistance = 10000.0;   // 10kΩ (poor air quality)
      float max_resistance = 200000.0;  // 200kΩ (excellent air quality)
      
      if (gas_val <= min_resistance) return 0;
      if (gas_val >= max_resistance) return 100;
      
      // Linear interpolation between min and max
      float percentage = ((gas_val - min_resistance) / (max_resistance - min_resistance)) * 100.0;
      return percentage;

# Text sensors for diagnostics
text_sensor:
  # Device info
  - platform: version
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic
  
  # WiFi info - REDUCED to save memory
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
      entity_category: diagnostic
    # DISABLED to save memory:
    # ssid:
    #   name: "${friendly_name} Connected SSID"
    #   entity_category: diagnostic
    # mac_address:
    #   name: "${friendly_name} Mac Address"
    #   entity_category: diagnostic
  
  # Power source detection
  - platform: template
    name: "Power Source"
    id: power_source
    entity_category: diagnostic
    lambda: |-
      float voltage = id(battery_voltage).state;
      if (voltage >= 4.15) {
        return {"Charging/Full"};
      } else if (voltage >= 3.2) {
        return {"Battery Power"};
      } else {
        return {"Low Battery"};
      }
    update_interval: ${battery_update_interval}
  
  # Air Quality Description
  - platform: template
    name: "Air Quality"
    id: air_quality_text
    icon: "mdi:air-filter"
    lambda: |-
      float gas_val = id(gas_resistance).state;
      
      if (gas_val >= 150000) {
        return {"Excellent"};
      } else if (gas_val >= 100000) {
        return {"Good"};
      } else if (gas_val >= 50000) {
        return {"Moderate"};
      } else if (gas_val >= 25000) {
        return {"Unhealthy for Sensitive"};
      } else if (gas_val >= 10000) {
        return {"Unhealthy"};
      } else {
        return {"Very Unhealthy"};
      }

# Binary sensors
binary_sensor:
  # Device status
  - platform: status
    name: "Status"
    entity_category: diagnostic
  
  # Low battery alert
  - platform: template
    name: "${friendly_name} Low Battery"
    id: low_battery
    device_class: battery
    entity_category: diagnostic
    lambda: |-
      return id(battery_voltage).state < ${low_battery_threshold};

# Number inputs for configuration
number:
  # NOTE: Sleep interval removed - configure via sleep_duration substitution at top of file
  
  # Temperature calibration offset (runtime adjustable in Fahrenheit)
  - platform: template
    name: "Temperature Offset"
    id: temperature_offset_input
    entity_category: config
    min_value: -18.0  # -10°C in Fahrenheit
    max_value: 18.0   # +10°C in Fahrenheit
    step: 0.1
    mode: box
    unit_of_measurement: "°F"
    icon: "mdi:thermometer"
    optimistic: true
    restore_value: true
    # No initial_value - will restore from HA or use min_value on first boot
    on_value:
      then:
        - logger.log:
            format: "Temperature offset changed to %.1f°F (takes effect immediately)"
            args: ['x']
  
  # Pressure calibration offset (runtime adjustable)
  - platform: template
    name: "Pressure Offset"
    id: pressure_offset_input
    entity_category: config
    min_value: -50.0
    max_value: 50.0
    step: 0.1
    mode: box
    unit_of_measurement: "hPa"
    icon: "mdi:gauge"
    optimistic: true
    restore_value: true
    # No initial_value - will restore from HA or use min_value on first boot
    on_value:
      then:
        - logger.log:
            format: "Pressure offset changed to %.1f hPa (takes effect immediately)"
            args: ['x']
  
  # Humidity calibration offset (runtime adjustable)
  - platform: template
    name: "Humidity Offset"
    id: humidity_offset_input
    entity_category: config
    min_value: -20.0
    max_value: 20.0
    step: 0.1
    mode: box
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    optimistic: true
    restore_value: true
    # No initial_value - will restore from HA or use min_value on first boot
    on_value:
      then:
        - logger.log:
            format: "Humidity offset changed to %.1f%% (takes effect immediately)"
            args: ['x']
  
  # Voltage divider multiplier (runtime adjustable for easy calibration)
  # NOTE: Set to your calibrated value (7.3) in HA - will restore from HA on subsequent boots
  - platform: template
    name: "Voltage Multiplier"
    entity_category: config
    id: voltage_multiplier_input
    min_value: 0.1
    max_value: 10.0
    step: 0.01
    mode: box
    unit_of_measurement: "x"
    icon: "mdi:multiplication"
    optimistic: true
    restore_value: true
    # No initial_value - will restore from HA. Set to 7.3 in HA for your hardware
    on_value:
      then:
        - logger.log:
            format: "Voltage multiplier changed to %.2fx (takes effect immediately)"
            args: ['x']

  # Gas resistance calibration offset (runtime adjustable)
  - platform: template
    name: "Gas Resistance Offset"
    id: gas_resistance_offset_input
    entity_category: config
    min_value: -100.0  # -100kΩ adjustment range
    max_value: 100.0   # +100kΩ adjustment range
    step: 1.0
    mode: box
    unit_of_measurement: "kΩ"
    icon: "mdi:gas-cylinder"
    optimistic: true
    restore_value: true
    # No initial_value - will restore from HA or use min_value on first boot
    on_value:
      then:
        - logger.log:
            format: "Gas resistance offset changed to %.1fkΩ (takes effect immediately)"
            args: ['x']

  # Sleep interval (runtime adjustable in minutes)
  - platform: template
    name: "Sleep Interval"
    id: sleep_interval_input
    entity_category: config
    min_value: 0.5  # 30 seconds minimum
    max_value: 120.0  # 2 hours maximum
    step: 0.5
    mode: box
    unit_of_measurement: "min"
    icon: "mdi:sleep"
    optimistic: true
    restore_value: true
    # No initial_value - will restore from HA or use min_value (0.5 min) on first boot
    on_value:
      then:
        - logger.log:
            format: "Sleep interval changed to %.1f minutes (takes effect on next sleep cycle)"
            args: ['x']
        # Update the deep sleep component with new duration
        - lambda: |-
            float minutes = x;
            uint32_t milliseconds = (uint32_t)(minutes * 60.0 * 1000.0);
            ESP_LOGI("deep_sleep", "Updating sleep duration to %.1f minutes (%u ms)", minutes, milliseconds);
            id(deep_sleep_control).set_sleep_duration(milliseconds);

# Switches for control
switch:
  # Restart switch
  - platform: restart
    name: "Restart"
    entity_category: config
  
  # Deep sleep toggle (maintains state properly)
  - platform: template
    name: "Deep Sleep Mode"
    id: deep_sleep_toggle
    entity_category: config
    optimistic: true  # Maintain local state to prevent resets
    restore_mode: RESTORE_DEFAULT_OFF  # Default to OFF for safety, but restore HA changes
    turn_on_action:
      - logger.log: "Deep sleep enabled via Home Assistant - will take effect on next boot cycle"
      - if:
          condition:
            lambda: 'return strcmp("${deep_sleep_enabled}", "true") == 0;'
          then:
            - logger.log: "Deep sleep firmware active - device will sleep after next readings"
          else:
            - logger.log: "Deep sleep not compiled in firmware - please reflash with deep_sleep_enabled: true"
    turn_off_action:
      - logger.log: "Deep sleep DISABLED via Home Assistant - device will stay awake"
      - homeassistant.service:
          service: notify.notify
          data:
            title: "${friendly_name}"
            message: "Deep sleep disabled - device will stay awake after next wake cycle"
    on_turn_on:
      - logger.log: "Deep sleep switch turned ON"
    on_turn_off:
      - logger.log: "Deep sleep switch turned OFF"

# Buttons for manual control
button:
  - platform: template
    name: "Enter Deep Sleep Now"
    id: manual_deep_sleep
    entity_category: config
    on_press:
      - if:
          condition:
            lambda: 'return strcmp("${deep_sleep_enabled}", "true") == 0;'
          then:
            - logger.log: "Manual deep sleep requested - entering sleep mode"
            - homeassistant.service:
                service: notify.notify
                data:
                  title: "${friendly_name}"
                  message: "Manual deep sleep activated via button"
            - deep_sleep.enter: deep_sleep_control
          else:
            - logger.log: "Deep sleep not compiled in firmware - cannot enter deep sleep"
            - homeassistant.service:
                service: notify.notify
                data:
                  title: "${friendly_name}"
                  message: "Deep sleep not available - reflash with deep_sleep_enabled: true"

# Time component (optional, for time-based automations)
time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: "America/New_York"  # Adjust to your timezone

# Interval components for different modes
interval:
  # Normal mode: Update sensors every 30 seconds (only when deep sleep disabled)
  - interval: 30s
    then:
      - if:
          condition:
            # Only run in normal mode (either compile-time disabled OR runtime switch off)
            lambda: |-
              bool compile_time_enabled = (strcmp("${deep_sleep_enabled}", "true") == 0);
              bool runtime_switch_enabled = id(deep_sleep_toggle).state;
              return !(compile_time_enabled && runtime_switch_enabled);
          then:
            - logger.log: "Normal mode - updating sensors"
            - component.update: bme680_sensor
            - component.update: battery_voltage
  
  # Watchdog timer for deep sleep mode - force sleep if something goes wrong
  - interval: 5min
    then:
      - if:
          condition:
            # Only activate watchdog when deep sleep is both compiled and runtime enabled
            lambda: |-
              bool compile_time_enabled = (strcmp("${deep_sleep_enabled}", "true") == 0);
              bool runtime_switch_enabled = id(deep_sleep_toggle).state;
              return compile_time_enabled && runtime_switch_enabled;
          then:
            - logger.log: "Watchdog timer - forcing deep sleep"
            - deep_sleep.enter: deep_sleep_control

# Status LED (optional - disable to save power)
status_led:
  pin:
    number: GPIO2  # Built-in LED on Wemos D1 Mini
    inverted: true
