# ESP Home Environmental Sensor Configuration
# Wemos D1 Mini + BME680 + 18650 Battery
# Deep sleep enabled for extended battery life

substitutions:
  device_name: "s1"
  friendly_name: "Environmental Sensor 01 (${device_name})"
  device_description: "Battery powered environmental sensor with BME680"
  
  # Deep sleep configuration 
  # IMPORTANT: Set to "false" for initial setup and programming
  # Set to "true" for battery-powered operation (requires D0-RST connection)
  deep_sleep_enabled: "true"  # Change to "true" to enable deep sleep mode
  sleep_duration: "1min"  # How long to sleep between readings (only when deep sleep enabled)
  
  # Battery monitoring
  battery_update_interval: "60s"  # Battery check interval (normal mode)
  low_battery_threshold: "3.2"  # Voltage threshold for low battery alert (18650 cutoff)
  
  # NOTE: Sensor calibration now handled via runtime number inputs (removed static offsets)

# set platform and board
esp8266:
  board: esp01_1m

esphome:
  name: "${device_name}"
  friendly_name: ${friendly_name}
  comment: ${device_description}
  
  # Boot priority and initial setup
  on_boot:
    priority: -100
    then:
      - logger.log: "Device booted, starting sensor readings..."
      - delay: 2s  # Allow sensors to stabilize
      # Send wake-up notification to Home Assistant - DISABLED to save memory
      - delay: 3s  # Wait for battery sensor to be ready
      # - homeassistant.service:
      #     service: notify.notify
      #     data:
      #       title: "${friendly_name}"
      #       message: "Device woke up and is taking sensor readings"
      - if:
          condition:
            # Check both compile-time setting AND runtime switch state
            lambda: |-
              bool compile_time_enabled = (strcmp("${deep_sleep_enabled}", "true") == 0);
              bool runtime_switch_enabled = id(deep_sleep_toggle).state;
              return compile_time_enabled && runtime_switch_enabled;
          then:
            - logger.log: "Deep sleep mode active - taking readings and sleeping"
            # In deep sleep mode, take readings immediately then sleep
            - component.update: bme680_sensor
            - component.update: battery_voltage
            - delay: 20s  # Allow readings to complete and transmit
            - logger.log: "Entering deep sleep"
            # double check that we still have deep sleep enabled
            - if:
                condition:
                  lambda: 'return strcmp("${deep_sleep_enabled}", "true") == 0;'
                then:
                  - logger.log: "Deep sleep still enabled - proceeding to sleep"
                  - deep_sleep.enter: deep_sleep_control
                else:
                  - logger.log: "Deep sleep disabled at runtime - staying awake"
          else:
            - if:
                condition:
                  lambda: 'return strcmp("${deep_sleep_enabled}", "true") == 0;'
                then:
                  - logger.log: "Deep sleep compiled but disabled by switch - normal operation"
                else:
                  - logger.log: "Normal mode - continuous operation with 30s intervals"

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${device_name} Fallback"
    password: !secret ap_password

# Captive portal for easy WiFi configuration
captive_portal:

# Enable logging
logger:
  level: WARN  # Reduced logging to save memory
  baud_rate: 0  # Disable serial logging to save power

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key
  
  # Services for remote control
  services:
    - service: start_deep_sleep
      then:
        - logger.log: "Starting deep sleep via service call"
        - homeassistant.service:
            service: notify.notify
            data:
              title: "${friendly_name}"
              message: "Manually entering deep sleep mode"
        - deep_sleep.enter: deep_sleep_control
    


# Enable OTA updates
ota:
  platform: esphome
  password: !secret ota_password

# Web server for diagnostics (optional - disable to save power)
# DISABLED: Saves memory for battery-powered operation
# web_server:
#   port: 80
#   auth:
#     username: !secret web_username
#     password: !secret web_password

# Deep sleep configuration (only active when deep_sleep_enabled is "true")
# IMPORTANT: For deep sleep to work, you MUST connect GPIO16 (D0) to RST pin
# This allows the ESP8266 to wake itself up from deep sleep
deep_sleep:
  id: deep_sleep_control
  sleep_duration: ${sleep_duration}
  # Note: ESP8266 doesn't support wakeup_pin - uses GPIO16 to RST connection instead

# I2C configuration for BME680
i2c:
  sda: GPIO4  # D2 on Wemos D1 Mini
  scl: GPIO5  # D1 on Wemos D1 Mini
  scan: true
  frequency: 100kHz

# BME680 sensor configuration
sensor:
  # BME680 Environmental Sensor
  - platform: bme680
    id: bme680_sensor
    temperature:
      name: "${friendly_name} Temperature"
      id: temperature
      accuracy_decimals: 1
      filters:
        # Runtime calibration via lambda using number input (Fahrenheit to Celsius conversion)
        - lambda: |-
            float offset_f = id(temperature_offset_input).state;
            float offset_c = offset_f / 1.8;  // Convert Fahrenheit offset to Celsius
            return x + offset_c;
    pressure:
      name: "${friendly_name} Pressure"
      id: pressure
      accuracy_decimals: 1
      filters:
        # Runtime calibration via lambda using number input
        - lambda: 'return x + id(pressure_offset_input).state;'
    humidity:
      name: "${friendly_name} Humidity"
      id: humidity
      accuracy_decimals: 1
      filters:
        # Runtime calibration via lambda using number input
        - lambda: 'return x + id(humidity_offset_input).state;'
    gas_resistance:
      name: "${friendly_name} Gas Resistance"
      id: gas_resistance
      accuracy_decimals: 0
    address: 0x77  # Default I2C address (0x76 is also common)
    update_interval: never  # Will be manually triggered in both modes
    
    # BME680 specific configuration
    iir_filter: 3x  # Internal IIR filter
    heater:
      temperature: 320  # Heater temperature in Celsius
      duration: 150ms
  
  # Battery voltage monitoring
  - platform: adc
    pin: A0
    name: "${friendly_name} Battery Voltage"
    id: battery_voltage
    update_interval: ${battery_update_interval}
    accuracy_decimals: 2
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    filters:
      # Convert ADC reading to voltage using runtime adjustable multiplier
      - lambda: |-
          float multiplier = id(voltage_multiplier_input).state;
          return x * multiplier;
    on_value:
      then:
        - if:
            condition:
              lambda: 'return x < ${low_battery_threshold};'  # Low battery threshold
            then:
              - logger.log: 
                  format: "Low battery detected: %.2fV"
                  args: ['x']
              - homeassistant.service:
                  service: notify.notify
                  data:
                    title: "${friendly_name}"
                    message: "Low battery detected - check device"
                    priority: high
  
  # Battery level percentage (calculated from voltage)
  - platform: template
    name: "${friendly_name} Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      float voltage = id(battery_voltage).state;
      
      // Li-ion battery discharge curve (3.2V - 4.2V range)
      if (voltage >= 4.1) return 100;
      if (voltage >= 4.0) return 95;
      if (voltage >= 3.9) return 85;
      if (voltage >= 3.8) return 75;
      if (voltage >= 3.7) return 65;
      if (voltage >= 3.6) return 45;
      if (voltage >= 3.5) return 30;
      if (voltage >= 3.4) return 15;
      if (voltage >= 3.3) return 5;
      if (voltage >= 3.2) return 1;
      return 0;  // Battery critically low
    update_interval: ${battery_update_interval}
  
  # WiFi signal strength
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    id: wifi_signal_db
    update_interval: ${battery_update_interval}
    accuracy_decimals: 0
    device_class: signal_strength
    state_class: measurement
    entity_category: diagnostic
  
  # Uptime sensor
  - platform: uptime
    name: "${friendly_name} Uptime"
    id: uptime_sensor
    update_interval: ${battery_update_interval}
    entity_category: diagnostic
  
  # Current sleep interval display - DISABLED to save memory
  # - platform: template
  #   name: "${friendly_name} Sleep Interval Setting"
  #   id: sleep_interval_display
  #   unit_of_measurement: "min"
  #   accuracy_decimals: 0
  #   state_class: measurement
  #   entity_category: diagnostic
  #   icon: "mdi:sleep"
  #   lambda: |-
  #     return 15.0; // Matches sleep_duration substitution default
  #   update_interval: 60s
  
  # NOTE: Calibrated sensors removed - use runtime offset number inputs instead
  # Temperature/Pressure/Humidity offsets are applied directly via filters in BME680 sensor
  
  # Air Quality Index (calculated from gas resistance)
  - platform: template
    name: "${friendly_name} Air Quality Index"
    id: air_quality_index
    unit_of_measurement: "AQI"
    device_class: aqi
    state_class: measurement
    accuracy_decimals: 0
    icon: "mdi:air-filter"
    lambda: |-
      float gas_val = id(gas_resistance).state;
      
      // BME680 gas resistance to AQI conversion
      // Higher gas resistance = better air quality
      // Typical ranges: 10kΩ (poor) to 200kΩ+ (excellent)
      
      if (gas_val >= 150000) {
        return 50;   // Excellent (0-50 AQI)
      } else if (gas_val >= 100000) {
        return 75;   // Good (51-100 AQI)
      } else if (gas_val >= 50000) {
        return 125;  // Moderate (101-150 AQI)
      } else if (gas_val >= 25000) {
        return 175;  // Unhealthy for sensitive (151-200 AQI)
      } else if (gas_val >= 10000) {
        return 225;  // Unhealthy (201-250 AQI)
      } else {
        return 300;  // Very Unhealthy/Hazardous (251+ AQI)
      }
    update_interval: ${battery_update_interval}
  
  # Air Quality Percentage (0-100% scale)
  - platform: template
    name: "${friendly_name} Air Quality Percentage"
    id: air_quality_percentage
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 0
    icon: "mdi:leaf"
    lambda: |-
      float gas_val = id(gas_resistance).state;
      
      // Convert gas resistance to 0-100% scale
      // 10kΩ = 0%, 200kΩ = 100%
      float min_resistance = 10000.0;   // 10kΩ (poor air quality)
      float max_resistance = 200000.0;  // 200kΩ (excellent air quality)
      
      if (gas_val <= min_resistance) return 0;
      if (gas_val >= max_resistance) return 100;
      
      // Linear interpolation between min and max
      float percentage = ((gas_val - min_resistance) / (max_resistance - min_resistance)) * 100.0;
      return percentage;
    update_interval: ${battery_update_interval}

# Text sensors for diagnostics
text_sensor:
  # Device info
  - platform: version
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic
  
  # WiFi info - REDUCED to save memory
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
      entity_category: diagnostic
    # DISABLED to save memory:
    # ssid:
    #   name: "${friendly_name} Connected SSID"
    #   entity_category: diagnostic
    # mac_address:
    #   name: "${friendly_name} Mac Address"
    #   entity_category: diagnostic
  
  # Power source detection
  - platform: template
    name: "${friendly_name} Power Source"
    id: power_source
    entity_category: diagnostic
    lambda: |-
      float voltage = id(battery_voltage).state;
      if (voltage >= 4.15) {
        return {"Charging/Full"};
      } else if (voltage >= 3.2) {
        return {"Battery Power"};
      } else {
        return {"Low Battery"};
      }
    update_interval: ${battery_update_interval}
  
  # Air Quality Description
  - platform: template
    name: "${friendly_name} Air Quality"
    id: air_quality_text
    icon: "mdi:air-filter"
    lambda: |-
      float gas_val = id(gas_resistance).state;
      
      if (gas_val >= 150000) {
        return {"Excellent"};
      } else if (gas_val >= 100000) {
        return {"Good"};
      } else if (gas_val >= 50000) {
        return {"Moderate"};
      } else if (gas_val >= 25000) {
        return {"Unhealthy for Sensitive"};
      } else if (gas_val >= 10000) {
        return {"Unhealthy"};
      } else {
        return {"Very Unhealthy"};
      }
    update_interval: ${battery_update_interval}

# Binary sensors
binary_sensor:
  # Device status
  - platform: status
    name: "${friendly_name} Status"
    entity_category: diagnostic
  
  # Low battery alert
  - platform: template
    name: "${friendly_name} Low Battery"
    id: low_battery
    device_class: battery
    entity_category: diagnostic
    lambda: |-
      return id(battery_voltage).state < ${low_battery_threshold};

# Number inputs for configuration
number:
  # NOTE: Sleep interval removed - configure via sleep_duration substitution at top of file
  
  # Temperature calibration offset (runtime adjustable in Fahrenheit)
  - platform: template
    name: "${friendly_name} Temperature Offset"
    id: temperature_offset_input
    entity_category: config
    min_value: -18.0  # -10°C in Fahrenheit
    max_value: 18.0   # +10°C in Fahrenheit
    step: 0.1
    mode: box
    unit_of_measurement: "°F"
    icon: "mdi:thermometer"
    optimistic: true
    restore_value: true
    on_value:
      then:
        - logger.log:
            format: "Temperature offset changed to %.1f°F (takes effect immediately)"
            args: ['x']
  
  # Pressure calibration offset (runtime adjustable)
  - platform: template
    name: "${friendly_name} Pressure Offset"
    id: pressure_offset_input
    entity_category: config
    min_value: -50.0
    max_value: 50.0
    step: 0.1
    mode: box
    unit_of_measurement: "hPa"
    icon: "mdi:gauge"
    optimistic: true
    restore_value: true
    on_value:
      then:
        - logger.log:
            format: "Pressure offset changed to %.1f hPa (takes effect immediately)"
            args: ['x']
  
  # Humidity calibration offset (runtime adjustable)
  - platform: template
    name: "${friendly_name} Humidity Offset"
    id: humidity_offset_input
    entity_category: config
    min_value: -20.0
    max_value: 20.0
    step: 0.1
    mode: box
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    optimistic: true
    restore_value: true
    on_value:
      then:
        - logger.log:
            format: "Humidity offset changed to %.1f%% (takes effect immediately)"
            args: ['x']
  
  # Voltage divider multiplier (runtime adjustable for easy calibration)
  # NOTE: Set to 7.3 in HA on first setup - will restore HA values on reboots
  - platform: template
    name: "${friendly_name} Voltage Multiplier"
    id: voltage_multiplier_input
    min_value: 0.1
    max_value: 10.0
    step: 0.01
    mode: box
    unit_of_measurement: "x"
    icon: "mdi:multiplication"
    optimistic: true
    restore_value: true
    on_value:
      then:
        - logger.log:
            format: "Voltage multiplier changed to %.2fx (takes effect immediately)"
            args: ['x']

# Switches for control
switch:
  # Restart switch
  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: config
  
  # Deep sleep toggle (takes effect immediately when firmware supports it)
  - platform: template
    name: "${friendly_name} Deep Sleep Mode"
    id: deep_sleep_toggle
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    on_turn_on:
      - logger.log: "Deep sleep enabled via switch"
      - if:
          condition:
            lambda: 'return strcmp("${deep_sleep_enabled}", "true") == 0;'
          then:
            - logger.log: "Deep sleep firmware active - will sleep on next cycle"
          else:
            - logger.log: "Deep sleep not compiled in firmware - please reflash with deep_sleep_enabled: true"
    on_turn_off:
      - logger.log: "Deep sleep disabled via switch - switching to normal mode"

# Buttons for manual control
button:
  - platform: template
    name: "${friendly_name} Enter Deep Sleep Now"
    id: manual_deep_sleep
    entity_category: config
    on_press:
      - if:
          condition:
            lambda: 'return strcmp("${deep_sleep_enabled}", "true") == 0;'
          then:
            - logger.log: "Manual deep sleep requested - entering sleep mode"
            - homeassistant.service:
                service: notify.notify
                data:
                  title: "${friendly_name}"
                  message: "Manual deep sleep activated via button"
            - deep_sleep.enter: deep_sleep_control
          else:
            - logger.log: "Deep sleep not compiled in firmware - cannot enter deep sleep"
            - homeassistant.service:
                service: notify.notify
                data:
                  title: "${friendly_name}"
                  message: "Deep sleep not available - reflash with deep_sleep_enabled: true"

# Time component (optional, for time-based automations)
time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: "America/New_York"  # Adjust to your timezone

# Interval components for different modes
interval:
  # Normal mode: Update sensors every 30 seconds (only when deep sleep disabled)
  - interval: 30s
    then:
      - if:
          condition:
            # Only run in normal mode (either compile-time disabled OR runtime switch off)
            lambda: |-
              bool compile_time_enabled = (strcmp("${deep_sleep_enabled}", "true") == 0);
              bool runtime_switch_enabled = id(deep_sleep_toggle).state;
              return !(compile_time_enabled && runtime_switch_enabled);
          then:
            - logger.log: "Normal mode - updating sensors"
            - component.update: bme680_sensor
            - component.update: battery_voltage
  
  # Watchdog timer for deep sleep mode - force sleep if something goes wrong
  - interval: 5min
    then:
      - if:
          condition:
            # Only activate watchdog when deep sleep is both compiled and runtime enabled
            lambda: |-
              bool compile_time_enabled = (strcmp("${deep_sleep_enabled}", "true") == 0);
              bool runtime_switch_enabled = id(deep_sleep_toggle).state;
              return compile_time_enabled && runtime_switch_enabled;
          then:
            - logger.log: "Watchdog timer - forcing deep sleep"
            - deep_sleep.enter: deep_sleep_control

# Status LED (optional - disable to save power)
status_led:
  pin:
    number: GPIO2  # Built-in LED on Wemos D1 Mini
    inverted: true
